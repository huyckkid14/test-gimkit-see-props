<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AI ZIP Image Similarity (Progress + ETA + Prop Names + px-ignore)</title>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<style>
body{
  background:#111;
  color:white;
  font-family:Arial;
  text-align:center;
  padding:20px;
}
input{ margin:10px; }
img{
  max-width:200px;
  border:2px solid #444;
  margin:10px;
}
#result{
  font-size:22px;
  margin-top:20px;
}

/* Progress UI */
#progressWrap{
  width:80%;
  max-width:700px;
  margin:18px auto;
  display:none;
}
#progressContainer{
  width:100%;
  height:20px;
  background:#333;
  border-radius:10px;
  overflow:hidden;
  border:1px solid #444;
}
#progressBar{
  height:100%;
  width:0%;
  background:linear-gradient(90deg,#00ff99,#00ccff);
  transition:width 0.15s linear;
}
#progressText{
  margin-top:10px;
  font-size:14px;
  color:#ddd;
}
.small{
  font-size:12px;
  color:#aaa;
}
</style>
</head>
<body>

<h2>AI Image Similarity (Neural Network + ZIP + TXT Map)</h2>

Target image:
<input type="file" id="img1Input" accept="image/*">

Props ZIP:
<input type="file" id="zipInput" accept=".zip">

Props TXT:
<input type="file" id="txtInput" accept=".txt">

<div>
  <img id="img1Preview">
</div>

<div id="result">Loading AI model...</div>

<div id="progressWrap">
  <div id="progressContainer">
    <div id="progressBar"></div>
  </div>
  <div id="progressText"></div>
</div>

<div id="bestMatch"></div>

<script>
let model;
let img1Ready = false;
let propsImages = [];
let propNameMap = {}; // filename -> prop name

const img1Preview = document.getElementById("img1Preview");
const result = document.getElementById("result");
const bestMatch = document.getElementById("bestMatch");

const progressWrap = document.getElementById("progressWrap");
const progressBar = document.getElementById("progressBar");
const progressText = document.getElementById("progressText");

async function loadModel() {
  model = await mobilenet.load({version:2, alpha:1.0});
  result.textContent = "Model loaded. Upload target image, ZIP, and TXT.";
}
loadModel();

function cosineSimilarity(a, b) {
  let dot = 0, na = 0, nb = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
    na += a[i] * a[i];
    nb += b[i] * b[i];
  }
  return dot / (Math.sqrt(na) * Math.sqrt(nb));
}

async function getEmbedding(img) {
  const tensor = tf.browser.fromPixels(img)
    .resizeNearestNeighbor([224,224])
    .toFloat()
    .expandDims();
  const emb = model.infer(tensor, true);
  const data = await emb.data();
  tf.dispose([tensor, emb]);
  return data;
}

function formatTime(seconds) {
  seconds = Math.max(0, Math.round(seconds));
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  if (m > 0) return `${m}m ${s}s`;
  return `${s}s`;
}

function resetProgress(){
  progressWrap.style.display = "none";
  progressBar.style.width = "0%";
  progressText.textContent = "";
  bestMatch.innerHTML = "";
}

/* TARGET IMAGE */
document.getElementById("img1Input").addEventListener("change", e => {
  const file = e.target.files[0];
  if(!file) return;

  resetProgress();

  const reader = new FileReader();
  reader.onload = () => {
    img1Preview.src = reader.result;
    img1Preview.onload = () => {
      img1Ready = true;
      tryCompare();
    };
  };
  reader.readAsDataURL(file);
});

/* TXT MAP UPLOAD */
document.getElementById("txtInput").addEventListener("change", async e => {
  const file = e.target.files[0];
  if(!file) return;

  const text = await file.text();
  propNameMap = {};

  text.split("\n").forEach(line => {
    // filepath: Gimkit Props/Sign_2.png  Prop name: Wooden Sign
    const match = line.match(/Gimkit Props\/(.+?)\s+Prop name:\s+(.+)/);
    if (!match) return;

    const filename = match[1].trim();
    const propName = match[2].trim();
    propNameMap[filename] = propName;
  });

  result.textContent = `Loaded ${Object.keys(propNameMap).length} prop names from TXT.`;
  tryCompare();
});

/* ZIP UPLOAD */
document.getElementById("zipInput").addEventListener("change", async e => {
  const file = e.target.files[0];
  if(!file) return;

  resetProgress();
  result.textContent = "Reading ZIP…";

  const zip = await JSZip.loadAsync(file);
  propsImages = [];

  for (let name in zip.files) {
    if (name.match(/\.(png|jpg|jpeg|webp)$/i)) {
      const blob = await zip.files[name].async("blob");
      const url = URL.createObjectURL(blob);

      // Remove folders AND ignore px sizes like 120px-, 240px-
      const cleanName = name
        .split("/")
        .pop()
        .replace(/^\d+px-/, "");

      propsImages.push({
        name: cleanName,
        url: url
      });
    }
  }

  result.textContent = `Loaded ${propsImages.length} images from ZIP.`;
  tryCompare();
});

async function tryCompare() {
  if (!img1Ready || !model || propsImages.length === 0 || Object.keys(propNameMap).length === 0) return;

  progressWrap.style.display = "block";
  result.textContent = "Analyzing target image…";

  const targetEmb = await getEmbedding(img1Preview);

  let bestScore = -1;
  let bestImage = null;
  let bestName = "";

  const total = propsImages.length;
  const startTime = performance.now();

  for (let i = 0; i < total; i++) {
    const { name, url } = propsImages[i];

    const img = new Image();
    img.src = url;
    await new Promise(r => img.onload = r);

    const emb = await getEmbedding(img);
    const score = cosineSimilarity(targetEmb, emb);

    if (score > bestScore) {
      bestScore = score;
      bestImage = url;
      bestName = name;
    }

    const done = i + 1;
    const pct = (done / total) * 100;
    progressBar.style.width = pct + "%";

    const elapsed = (performance.now() - startTime) / 1000;
    const avgPer = elapsed / done;
    const remaining = (total - done) * avgPer;

    result.textContent = `Analyzing ${done}/${total}…`;
    progressText.innerHTML = `
      Progress: <b>${pct.toFixed(2)}%</b><br>
      Elapsed: <b>${formatTime(elapsed)}</b><br>
      Estimated remaining: <b>${formatTime(remaining)}</b><br>
      Currently analyzing: <b>${name}</b><br>
      Best so far: <b>${(bestScore * 100).toFixed(2)}%</b>
      <div class="small">ETA stabilizes after some images.</div>
    `;
  }

  const propLabel = propNameMap[bestName] || "(Unknown Prop)";

  result.textContent = `Best match: ${(bestScore * 100).toFixed(2)}%`;
  bestMatch.innerHTML = `
    <div style="margin-top:10px;font-size:16px;">
      <b>Prop name:</b> ${propLabel}<br>
      <span class="small">File: ${bestName}</span>
    </div>
    <img src="${bestImage}">
  `;
}
</script>

</body>
</html>
